<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1491432442386">{:repl-history {:ide [], :local [&quot;(ns Uva301)\n\n(defn make-order [start end passengers]\n  ;Makes an order\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n\n(def empty-orders\n  \&quot;Empty list for test purposes\&quot;\n  (list ()))\n\n\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 10)                                 ;20\n        (make-order 0 2 1)                                  ;2\n        (make-order 0 3 1)                                  ;3\n        (make-order 1 3 5)                                  ;10\n        (make-order 1 2 7)                                  ;7\n        (make-order 2 3 10)                                 ;10\n        ))\n\n\n(def orders2\n  \&quot;Creates more mock orders\&quot;\n  (list (make-order 0 2 4)\n        (make-order 0 1 7)\n        (make-order 1 3 5)\n        (make-order 1 2 10)\n        (make-order 1 2 3)\n        (make-order 2 4 1)\n        (make-order 2 3 2)\n        (make-order 3 4 7)\n        (make-order 3 4 9)\n        (make-order 3 4 4)\n        ))\n\n\n(defn make-state [current-station end-station max-capacity]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard.\n   To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n\n(def start-state\n  \&quot;Defines the problem default start state\&quot;\n  (make-state 0 4 10))\n\n\n(defn move [c-state new-o]\n  \&quot;Moves through the orders updating the current status accepting or\n  rejecting orders subject to define conditions. Stores accept order states in hash map\&quot;\n  (let [c-station (get c-state :station)\n        n-station (inc c-station)\n        p-off (filter #(= (get % :end) c-station) (get c-state :current-passengers))\n        remaining-p (filter #(not (= (get % :end) c-station)) (get c-state :current-passengers))\n        reduce-cap (reduce #(+ %1 (get %2 :pass)) 0 p-off)\n        dep-cap (- (get c-state :current-capacity) reduce-cap)\n        accept-o (if (&lt;= (+ dep-cap (get new-o :pass)) (get c-state :max-capacity)) true false)\n        final-cap (if (true? accept-o) (+ dep-cap (get new-o :pass)) dep-cap)\n        val (if (true? accept-o) (+ (get c-state :value) (get new-o :value)) (get c-state :value))\n        c-route (if (true? accept-o) (conj (get c-state :route) new-o) (get c-state :route))\n        c-pass (if (true? accept-o) (conj remaining-p new-o) remaining-p)\n        ]\n\n    (hash-map :station n-station\n              :value val\n              :current-capacity final-cap\n              :max-capacity (get c-state :max-capacity)\n              :route c-route\n              :route-end (get c-state :route-end)\n              :current-passengers c-pass)))\n\n\n(defn lmg [states order]\n  \&quot;For each state maps all of the legal moves that can be reached.\n  Concatinating all of the different station states into one large list\&quot;\n  (let [fir (first states)]\n    (if (= (get fir :station)\n           (get fir :route-end))\n      states\n      (let [new-states (for [x states] (map #(move x %) (filter #(= (get % :start) (get x :station)) order)))]\n        (recur (apply concat new-states) order)))))\n\n\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end))\n;\n;  )\n(defn maxx-val [state order]\n  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n  (let [end (lmg (list (state)) order)]\n    (map #(select-keys % [:value]) end)))\n\n(defn omgffs [state order]\n  (let [please-work (maxx-val state order)]\n    (map :value\n         (filter #(if (and (map? %) (:value %)) true false)\n                 (tree-seq #(or (map? %) (vector? %)) identity please-work)))))\n\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (#(select-keys % [:value]) end)\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))\n\n;BELOW IS WHAT NEEDS DOING==============================================================================================\n; test harness completion\n; test data to break\n; need to get the max value from the map of values\n;Create a test harness that will check each of the values indivually\n\n;---------TESTING-----------\n; assert (= (get (move state )) :current-capacity)\n;(lmg (list (make-state 0 3 10)) orders)\n;(lmg (list (make-state 0 4 10)) order2)\n\n;(defn run-all-tests [tests]\n;  (mfor ['(?id ?test =&gt; ?res) tests]\n;        (if-not (= (eval (? test)) (eval (? res)))\n;          (println (mout '(FAILED ?id ?test =&gt; ?res))))) 'end-of-testing)\n;\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4] [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n;\n;;(defn max-val [state order]\n;;  (let [end (lmg (list (state)) order)]\n;;    (map #(select-keys % [:value]) end)\n;;    ))\n;\n;(def tests '([t1 ((max-val #(make-state 0 3 10) orders) =&gt; ({:value 30} {:value 30} {:value 12} {:value 19} {:value 13} {:value 10}))]\n;              [t1 (first ((max-val #(make-state 0 3 10) orders))) =&gt; {:value 30}]\n;\n;              ;(lmg (list (make-state 0 4 10)) order2)\n;\n;              ))\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4]\n;              [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n\n;(def data [{:date1 \&quot;20131007\&quot;, :data \&quot;object1\&quot;, :counter 1000}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object2\&quot;, :counter 50}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object3\&quot;, :counter 230}])\n;\n;(def counters (map :counter data))      ; =&gt; (100 50 230)\n;(def min-value (apply min counters))    ; =&gt; 50\n;(def max-value (apply max counters))    ; =&gt; 1000\n;(def val-range (- max-value min-value)) ; =&gt; 950\n;(def val-pc (* (/ val-range 100) 10))   ; =&gt; 95\n;(def x (- max-value val-pc))            ; =&gt; 905\n\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    end))\n\n\n\n;Old shit\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (for [n end] (get (nth end n) :value)\n;    )))\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (get (nthrest end 0) :value)\n;    ))\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    (first end)))\n\n&quot; &quot;(defn maxx-val [state order]\n  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n  (let [end (lmg (list (state)) order)]\n    (map #(select-keys % [:value]) end)))\n\n(defn omgffs [state order]\n  (let [please-work (maxx-val state order)]\n    (map :value\n         (filter #(if (and (map? %) (:value %)) true false)\n                 (tree-seq #(or (map? %) (vector? %)) identity please-work)))))&quot; &quot;(lmg (list (make-state 0 3 10)) orders)&quot; &quot;(maxx-val (make-state 0 3 10) orders)&quot; &quot;;(lmg (list (make-state 0 3 10)) orders)&quot; &quot;(defn maxx-val [state order]\n  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n  (let [end (lmg (list (state)) order)]\n    (apply hash-map(map #(select-keys % [:value]) end))\n    (map :value\n         (filter #(if (and (map? %) (:value %)) true  false)\n                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n    ))\n\n(defn omgffs [state order]\n  (let [please-work (maxx-val state order)]\n    (map :value\n         (filter #(if (and (map? %) (:value %)) true false)\n                 (tree-seq #(or (map? %) (vector? %)) identity please-work)))))&quot; &quot;(ns Uva301)\n\n(defn make-order [start end passengers]\n  ;Makes an order\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n\n(def empty-orders\n  \&quot;Empty list for test purposes\&quot;\n  (list ()))\n\n\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 10)                                 ;20\n        (make-order 0 2 1)                                  ;2\n        (make-order 0 3 1)                                  ;3\n        (make-order 1 3 5)                                  ;10\n        (make-order 1 2 7)                                  ;7\n        (make-order 2 3 10)                                 ;10\n        ))\n\n\n(def orders2\n  \&quot;Creates more mock orders\&quot;\n  (list (make-order 0 2 4)\n        (make-order 0 1 7)\n        (make-order 1 3 5)\n        (make-order 1 2 10)\n        (make-order 1 2 3)\n        (make-order 2 4 1)\n        (make-order 2 3 2)\n        (make-order 3 4 7)\n        (make-order 3 4 9)\n        (make-order 3 4 4)\n        ))\n\n\n(defn make-state [current-station end-station max-capacity]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard.\n   To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n\n(def start-state\n  \&quot;Defines the problem default start state\&quot;\n  (make-state 0 4 10))\n\n\n(defn move [c-state new-o]\n  \&quot;Moves through the orders updating the current status accepting or\n  rejecting orders subject to define conditions. Stores accept order states in hash map\&quot;\n  (let [c-station (get c-state :station)\n        n-station (inc c-station)\n        p-off (filter #(= (get % :end) c-station) (get c-state :current-passengers))\n        remaining-p (filter #(not (= (get % :end) c-station)) (get c-state :current-passengers))\n        reduce-cap (reduce #(+ %1 (get %2 :pass)) 0 p-off)\n        dep-cap (- (get c-state :current-capacity) reduce-cap)\n        accept-o (if (&lt;= (+ dep-cap (get new-o :pass)) (get c-state :max-capacity)) true false)\n        final-cap (if (true? accept-o) (+ dep-cap (get new-o :pass)) dep-cap)\n        val (if (true? accept-o) (+ (get c-state :value) (get new-o :value)) (get c-state :value))\n        c-route (if (true? accept-o) (conj (get c-state :route) new-o) (get c-state :route))\n        c-pass (if (true? accept-o) (conj remaining-p new-o) remaining-p)\n        ]\n\n    (hash-map :station n-station\n              :value val\n              :current-capacity final-cap\n              :max-capacity (get c-state :max-capacity)\n              :route c-route\n              :route-end (get c-state :route-end)\n              :current-passengers c-pass)))\n\n\n(defn lmg [states order]\n  \&quot;For each state maps all of the legal moves that can be reached.\n  Concatinating all of the different station states into one large list\&quot;\n  (let [fir (first states)]\n    (if (= (get fir :station)\n           (get fir :route-end))\n      states\n      (let [new-states (for [x states] (map #(move x %) (filter #(= (get % :start) (get x :station)) order)))]\n        (recur (apply concat new-states) order)))))\n\n\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end))\n;\n;  )\n;(defn maxx-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end)))\n\n(defn maxx-val [state order]\n  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n  (let [end (lmg (list (state)) order)]\n    (apply hash-map(map #(select-keys % [:value]) end))\n    (map :value\n         (filter #(if (and (map? %) (:value %)) true  false)\n                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n    ))\n\n(defn omgffs [state order]\n  (let [please-work (maxx-val state order)]\n    (map :value\n         (filter #(if (and (map? %) (:value %)) true false)\n                 (tree-seq #(or (map? %) (vector? %)) identity please-work)))))\n\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (#(select-keys % [:value]) end)\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))\n\n;BELOW IS WHAT NEEDS DOING==============================================================================================\n; test harness completion\n; test data to break\n; need to get the max value from the map of values\n;Create a test harness that will check each of the values indivually\n\n;---------TESTING-----------\n; assert (= (get (move state )) :current-capacity)\n;(lmg (list (make-state 0 3 10)) orders)\n;(lmg (list (make-state 0 4 10)) order2)\n\n;(defn run-all-tests [tests]\n;  (mfor ['(?id ?test =&gt; ?res) tests]\n;        (if-not (= (eval (? test)) (eval (? res)))\n;          (println (mout '(FAILED ?id ?test =&gt; ?res))))) 'end-of-testing)\n;\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4] [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n;\n;;(defn max-val [state order]\n;;  (let [end (lmg (list (state)) order)]\n;;    (map #(select-keys % [:value]) end)\n;;    ))\n;\n;(def tests '([t1 ((max-val #(make-state 0 3 10) orders) =&gt; ({:value 30} {:value 30} {:value 12} {:value 19} {:value 13} {:value 10}))]\n;              [t1 (first ((max-val #(make-state 0 3 10) orders))) =&gt; {:value 30}]\n;\n;              ;(lmg (list (make-state 0 4 10)) order2)\n;\n;              ))\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4]\n;              [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n\n;(def data [{:date1 \&quot;20131007\&quot;, :data \&quot;object1\&quot;, :counter 1000}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object2\&quot;, :counter 50}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object3\&quot;, :counter 230}])\n;\n;(def counters (map :counter data))      ; =&gt; (100 50 230)\n;(def min-value (apply min counters))    ; =&gt; 50\n;(def max-value (apply max counters))    ; =&gt; 1000\n;(def val-range (- max-value min-value)) ; =&gt; 950\n;(def val-pc (* (/ val-range 100) 10))   ; =&gt; 95\n;(def x (- max-value val-pc))            ; =&gt; 905\n\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    end))\n\n\n\n;Old shit\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (for [n end] (get (nth end n) :value)\n;    )))\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (get (nthrest end 0) :value)\n;    ))\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    (first end)))\n\n&quot; &quot;(ns Uva301)\n\n(defn make-order [start end passengers]\n  ;Makes an order\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n\n(def empty-orders\n  \&quot;Empty list for test purposes\&quot;\n  (list ()))\n\n\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 10)                                 ;20\n        (make-order 0 2 1)                                  ;2\n        (make-order 0 3 1)                                  ;3\n        (make-order 1 3 5)                                  ;10\n        (make-order 1 2 7)                                  ;7\n        (make-order 2 3 10)                                 ;10\n        ))\n\n\n(def orders2\n  \&quot;Creates more mock orders\&quot;\n  (list (make-order 0 2 4)\n        (make-order 0 1 7)\n        (make-order 1 3 5)\n        (make-order 1 2 10)\n        (make-order 1 2 3)\n        (make-order 2 4 1)\n        (make-order 2 3 2)\n        (make-order 3 4 7)\n        (make-order 3 4 9)\n        (make-order 3 4 4)\n        ))\n\n\n(defn make-state [current-station end-station max-capacity]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard.\n   To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n\n(def start-state\n  \&quot;Defines the problem default start state\&quot;\n  (make-state 0 4 10))\n\n\n(defn move [c-state new-o]\n  \&quot;Moves through the orders updating the current status accepting or\n  rejecting orders subject to define conditions. Stores accept order states in hash map\&quot;\n  (let [c-station (get c-state :station)\n        n-station (inc c-station)\n        p-off (filter #(= (get % :end) c-station) (get c-state :current-passengers))\n        remaining-p (filter #(not (= (get % :end) c-station)) (get c-state :current-passengers))\n        reduce-cap (reduce #(+ %1 (get %2 :pass)) 0 p-off)\n        dep-cap (- (get c-state :current-capacity) reduce-cap)\n        accept-o (if (&lt;= (+ dep-cap (get new-o :pass)) (get c-state :max-capacity)) true false)\n        final-cap (if (true? accept-o) (+ dep-cap (get new-o :pass)) dep-cap)\n        val (if (true? accept-o) (+ (get c-state :value) (get new-o :value)) (get c-state :value))\n        c-route (if (true? accept-o) (conj (get c-state :route) new-o) (get c-state :route))\n        c-pass (if (true? accept-o) (conj remaining-p new-o) remaining-p)\n        ]\n\n    (hash-map :station n-station\n              :value val\n              :current-capacity final-cap\n              :max-capacity (get c-state :max-capacity)\n              :route c-route\n              :route-end (get c-state :route-end)\n              :current-passengers c-pass)))\n\n\n(defn lmg [states order]\n  \&quot;For each state maps all of the legal moves that can be reached.\n  Concatinating all of the different station states into one large list\&quot;\n  (let [fir (first states)]\n    (if (= (get fir :station)\n           (get fir :route-end))\n      states\n      (let [new-states (for [x states] (map #(move x %) (filter #(= (get % :start) (get x :station)) order)))]\n        (recur (apply concat new-states) order)))))\n\n\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end))\n;\n;  )\n(defn maxx-val [state order]\n  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n  (let [end (lmg (list (state)) order)]\n    (map #(select-keys % [:value]) end)))\n\n;(defn maxx-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (apply hash-map(map #(select-keys % [:value]) end))\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))\n\n(defn omgffs [state order]\n  (let [please-work (maxx-val state order)]\n    (map :value\n         (filter #(if (and (map? %) (:value %)) true false)\n                 (tree-seq #(or (map? %) (vector? %)) identity please-work)))))\n\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (#(select-keys % [:value]) end)\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))\n\n;BELOW IS WHAT NEEDS DOING==============================================================================================\n; test harness completion\n; test data to break\n; need to get the max value from the map of values\n;Create a test harness that will check each of the values indivually\n\n;---------TESTING-----------\n; assert (= (get (move state )) :current-capacity)\n;(lmg (list (make-state 0 3 10)) orders)\n;(lmg (list (make-state 0 4 10)) order2)\n\n;(defn run-all-tests [tests]\n;  (mfor ['(?id ?test =&gt; ?res) tests]\n;        (if-not (= (eval (? test)) (eval (? res)))\n;          (println (mout '(FAILED ?id ?test =&gt; ?res))))) 'end-of-testing)\n;\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4] [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n;\n;;(defn max-val [state order]\n;;  (let [end (lmg (list (state)) order)]\n;;    (map #(select-keys % [:value]) end)\n;;    ))\n;\n;(def tests '([t1 ((max-val #(make-state 0 3 10) orders) =&gt; ({:value 30} {:value 30} {:value 12} {:value 19} {:value 13} {:value 10}))]\n;              [t1 (first ((max-val #(make-state 0 3 10) orders))) =&gt; {:value 30}]\n;\n;              ;(lmg (list (make-state 0 4 10)) order2)\n;\n;              ))\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4]\n;              [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n\n;(def data [{:date1 \&quot;20131007\&quot;, :data \&quot;object1\&quot;, :counter 1000}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object2\&quot;, :counter 50}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object3\&quot;, :counter 230}])\n;\n;(def counters (map :counter data))      ; =&gt; (100 50 230)\n;(def min-value (apply min counters))    ; =&gt; 50\n;(def max-value (apply max counters))    ; =&gt; 1000\n;(def val-range (- max-value min-value)) ; =&gt; 950\n;(def val-pc (* (/ val-range 100) 10))   ; =&gt; 95\n;(def x (- max-value val-pc))            ; =&gt; 905\n\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    end))\n\n\n\n;Old shit\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (for [n end] (get (nth end n) :value)\n;    )))\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (get (nthrest end 0) :value)\n;    ))\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    (first end)))\n\n&quot; &quot;(ns Uva301)\n\n(defn make-order [start end passengers]\n  ;Makes an order\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n\n(def empty-orders\n  \&quot;Empty list for test purposes\&quot;\n  (list ()))\n\n\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 10)                                 ;20\n        (make-order 0 2 1)                                  ;2\n        (make-order 0 3 1)                                  ;3\n        (make-order 1 3 5)                                  ;10\n        (make-order 1 2 7)                                  ;7\n        (make-order 2 3 10)                                 ;10\n        ))\n\n\n(def orders2\n  \&quot;Creates more mock orders\&quot;\n  (list (make-order 0 2 4)\n        (make-order 0 1 7)\n        (make-order 1 3 5)\n        (make-order 1 2 10)\n        (make-order 1 2 3)\n        (make-order 2 4 1)\n        (make-order 2 3 2)\n        (make-order 3 4 7)\n        (make-order 3 4 9)\n        (make-order 3 4 4)\n        ))\n\n\n(defn make-state [current-station end-station max-capacity]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard.\n   To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n\n(def start-state\n  \&quot;Defines the problem default start state\&quot;\n  (make-state 0 4 10))\n\n\n(defn move [c-state new-o]\n  \&quot;Moves through the orders updating the current status accepting or\n  rejecting orders subject to define conditions. Stores accept order states in hash map\&quot;\n  (let [c-station (get c-state :station)\n        n-station (inc c-station)\n        p-off (filter #(= (get % :end) c-station) (get c-state :current-passengers))\n        remaining-p (filter #(not (= (get % :end) c-station)) (get c-state :current-passengers))\n        reduce-cap (reduce #(+ %1 (get %2 :pass)) 0 p-off)\n        dep-cap (- (get c-state :current-capacity) reduce-cap)\n        accept-o (if (&lt;= (+ dep-cap (get new-o :pass)) (get c-state :max-capacity)) true false)\n        final-cap (if (true? accept-o) (+ dep-cap (get new-o :pass)) dep-cap)\n        val (if (true? accept-o) (+ (get c-state :value) (get new-o :value)) (get c-state :value))\n        c-route (if (true? accept-o) (conj (get c-state :route) new-o) (get c-state :route))\n        c-pass (if (true? accept-o) (conj remaining-p new-o) remaining-p)\n        ]\n\n    (hash-map :station n-station\n              :value val\n              :current-capacity final-cap\n              :max-capacity (get c-state :max-capacity)\n              :route c-route\n              :route-end (get c-state :route-end)\n              :current-passengers c-pass)))\n\n\n(defn lmg [states order]\n  \&quot;For each state maps all of the legal moves that can be reached.\n  Concatinating all of the different station states into one large list\&quot;\n  (let [fir (first states)]\n    (if (= (get fir :station)\n           (get fir :route-end))\n      states\n      (let [new-states (for [x states] (map #(move x %) (filter #(= (get % :start) (get x :station)) order)))]\n        (recur (apply concat new-states) order)))))\n\n\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end))\n;\n;  )\n(defn maxx-val [state order]\n  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n  (let [end (lmg (list (state)) order)]\n    (apply hash-map(map #(select-keys % [:value]) end))))\n\n;(defn maxx-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (apply hash-map(map #(select-keys % [:value]) end))\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))\n\n(defn omgffs [state order]\n  (let [please-work (maxx-val state order)]\n    (map :value\n         (filter #(if (and (map? %) (:value %)) true false)\n                 (tree-seq #(or (map? %) (vector? %)) identity please-work)))))\n\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (#(select-keys % [:value]) end)\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))\n\n;BELOW IS WHAT NEEDS DOING==============================================================================================\n; test harness completion\n; test data to break\n; need to get the max value from the map of values\n;Create a test harness that will check each of the values indivually\n\n;---------TESTING-----------\n; assert (= (get (move state )) :current-capacity)\n;(lmg (list (make-state 0 3 10)) orders)\n;(lmg (list (make-state 0 4 10)) order2)\n\n;(defn run-all-tests [tests]\n;  (mfor ['(?id ?test =&gt; ?res) tests]\n;        (if-not (= (eval (? test)) (eval (? res)))\n;          (println (mout '(FAILED ?id ?test =&gt; ?res))))) 'end-of-testing)\n;\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4] [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n;\n;;(defn max-val [state order]\n;;  (let [end (lmg (list (state)) order)]\n;;    (map #(select-keys % [:value]) end)\n;;    ))\n;\n;(def tests '([t1 ((max-val #(make-state 0 3 10) orders) =&gt; ({:value 30} {:value 30} {:value 12} {:value 19} {:value 13} {:value 10}))]\n;              [t1 (first ((max-val #(make-state 0 3 10) orders))) =&gt; {:value 30}]\n;\n;              ;(lmg (list (make-state 0 4 10)) order2)\n;\n;              ))\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4]\n;              [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n\n;(def data [{:date1 \&quot;20131007\&quot;, :data \&quot;object1\&quot;, :counter 1000}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object2\&quot;, :counter 50}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object3\&quot;, :counter 230}])\n;\n;(def counters (map :counter data))      ; =&gt; (100 50 230)\n;(def min-value (apply min counters))    ; =&gt; 50\n;(def max-value (apply max counters))    ; =&gt; 1000\n;(def val-range (- max-value min-value)) ; =&gt; 950\n;(def val-pc (* (/ val-range 100) 10))   ; =&gt; 95\n;(def x (- max-value val-pc))            ; =&gt; 905\n\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    end))\n\n\n\n;Old shit\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (for [n end] (get (nth end n) :value)\n;    )))\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (get (nthrest end 0) :value)\n;    ))\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    (first end)))\n\n&quot; &quot;(maxx-val #(make-state 0 3 10) orders)&quot; &quot;(omgffs #(make-state 0 3 10) orders)&quot; &quot;(ns Uva301)\n;\n;(defn make-order [start end passengers]\n;  ;Makes an order\n;  \&quot;Creates a map start, end (station) and number of passengers.\n;  Also contains a function to calculate value.\&quot;\n;  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n;\n;\n;(def empty-orders\n;  \&quot;Empty list for test purposes\&quot;\n;  (list ()))\n;\n;\n;(def orders\n;  \&quot;Creates mock orders\&quot;\n;  (list (make-order 0 2 10)                                 ;20\n;        (make-order 0 2 1)                                  ;2\n;        (make-order 0 3 1)                                  ;3\n;        (make-order 1 3 5)                                  ;10\n;        (make-order 1 2 7)                                  ;7\n;        (make-order 2 3 10)                                 ;10\n;        ))\n;\n;\n;(def orders2\n;  \&quot;Creates more mock orders\&quot;\n;  (list (make-order 0 2 4)\n;        (make-order 0 1 7)\n;        (make-order 1 3 5)\n;        (make-order 1 2 10)\n;        (make-order 1 2 3)\n;        (make-order 2 4 1)\n;        (make-order 2 3 2)\n;        (make-order 3 4 7)\n;        (make-order 3 4 9)\n;        (make-order 3 4 4)\n;        ))\n;\n;\n;(defn make-state [current-station end-station max-capacity]\n;  \&quot;Defines the current state of station, capacity, route and passengers onboard.\n;   To work out passenger calculations\&quot;\n;  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n;            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n;\n;\n;(def start-state\n;  \&quot;Defines the problem default start state\&quot;\n;  (make-state 0 4 10))\n;\n;\n;(defn move [c-state new-o]\n;  \&quot;Moves through the orders updating the current status accepting or\n;  rejecting orders subject to define conditions. Stores accept order states in hash map\&quot;\n;  (let [c-station (get c-state :station)\n;        n-station (inc c-station)\n;        p-off (filter #(= (get % :end) c-station) (get c-state :current-passengers))\n;        remaining-p (filter #(not (= (get % :end) c-station)) (get c-state :current-passengers))\n;        reduce-cap (reduce #(+ %1 (get %2 :pass)) 0 p-off)\n;        dep-cap (- (get c-state :current-capacity) reduce-cap)\n;        accept-o (if (&lt;= (+ dep-cap (get new-o :pass)) (get c-state :max-capacity)) true false)\n;        final-cap (if (true? accept-o) (+ dep-cap (get new-o :pass)) dep-cap)\n;        val (if (true? accept-o) (+ (get c-state :value) (get new-o :value)) (get c-state :value))\n;        c-route (if (true? accept-o) (conj (get c-state :route) new-o) (get c-state :route))\n;        c-pass (if (true? accept-o) (conj remaining-p new-o) remaining-p)\n;        ]\n;\n;    (hash-map :station n-station\n;              :value val\n;              :current-capacity final-cap\n;              :max-capacity (get c-state :max-capacity)\n;              :route c-route\n;              :route-end (get c-state :route-end)\n;              :current-passengers c-pass)))\n;\n;\n;(defn lmg [states order]\n;  \&quot;For each state maps all of the legal moves that can be reached.\n;  Concatinating all of the different station states into one large list\&quot;\n;  (let [fir (first states)]\n;    (if (= (get fir :station)\n;           (get fir :route-end))\n;      states\n;      (let [new-states (for [x states] (map #(move x %) (filter #(= (get % :start) (get x :station)) order)))]\n;        (recur (apply concat new-states) order)))))\n;\n;\n;(defn map-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (apply hash-map (map #(select-keys % [:value]) end))))\n;\n;(defn max-val [state order]\n;  \&quot;gets the maxium from the list\&quot;\n;  (let [maximum (map-val state order)]\n;    (apply max (map :value\n;                    (filter #(if (and (map? %) (:value %)) true false)\n;                            (tree-seq #(or (map? %) (vector? %)) identity maximum))))))\n;\n\n\n;======================================================================================================================\n(ns GroupF-UVA301)\n\n(defn make-order [start end passengers]\n  ;Makes an order\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n\n(def empty-orders\n  \&quot;Empty list for test purposes\&quot;\n  (list ()))\n\n\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 10)                                 ;20\n        (make-order 0 2 1)                                  ;2\n        (make-order 0 3 1)                                  ;3\n        (make-order 1 3 5)                                  ;10\n        (make-order 1 2 7)                                  ;7\n        (make-order 2 3 10)                                 ;10\n        ))\n\n\n(def orders2\n  \&quot;Creates more mock orders\&quot;\n  (list (make-order 0 2 4)\n        (make-order 0 1 7)\n        (make-order 1 3 5)\n        (make-order 1 2 10)\n        (make-order 1 2 3)\n        (make-order 2 4 1)\n        (make-order 2 3 2)\n        (make-order 3 4 7)\n        (make-order 3 4 9)\n        (make-order 3 4 4)\n        ))\n\n\n(def orders3\n  \&quot;Creates more mock orders\&quot;\n  (list (make-order 0 3 4)\n        (make-order 0 1 1)\n        (make-order 1 3 6)\n        (make-order 1 2 10)\n        (make-order 1 2 1)\n        (make-order 2 4 6)\n        (make-order 2 3 2)\n        (make-order 3 4 7)\n        (make-order 3 4 9)\n        (make-order 3 4 4)\n        ))\n\n(def orders4\n  ;Makes oversized order for test\n  \&quot;Creates mock orders that is over the size limit\&quot;\n  (list (make-order 0 2 1)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 2 3 10)))\n\n\n(defn make-state [current-station end-station max-capacity]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard.\n   To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n(def start-state\n  \&quot;Defines the problem default start state\&quot;\n  (make-state 0 4 10))\n\n\n\n\n(defn move [c-state new-o]\n  \&quot;Moves through the orders updating the current status accepting or\n  rejecting orders subject to define conditions. Stores accept order states in hash map\&quot;\n  (let [c-station (get c-state :station)                                                                                ;Sets the current station\n        n-station (inc c-station)                                                                                       ;increments through the stations\n        p-off (filter #(= (get % :end) c-station) (get c-state :current-passengers))                                    ;Filters where the end station is equal to the current station, if it is it will then get the current passengers\n        remaining-p (filter #(not (= (get % :end) c-station)) (get c-state :current-passengers))                        ;Filters where the end station is not equal to the current station passngers will be staying on so get the current passengers\n        reduce-cap (reduce #(+ %1 (get %2 :pass)) 0 p-off)                                                              ;Start at 0 then adds the people that are getting off so it increases our capacity so that more people can get on\n        dep-cap (- (get c-state :current-capacity) reduce-cap)                                                          ;Gets the current capacity and reduced then takes them off leaving the current capacity when the train has dropped people off\n        accept-o (if (&lt;= (+ dep-cap (get new-o :pass)) (get c-state :max-capacity)) true false)                         ;If the capacity that is currently on the train + the new orders passengers is less than the max capacity it is true. Else false\n        final-cap (if (true? accept-o) (+ dep-cap (get new-o :pass)) dep-cap)                                           ;If true set accept the order and add the current capacity with the new order passengers\n        val (if (true? accept-o) (+ (get c-state :value) (get new-o :value)) (get c-state :value))                      ;If order taken update the value\n        c-route (if (true? accept-o) (conj (get c-state :route) new-o) (get c-state :route))                            ;If order taken conj the current route with the new order route, create a long list of the route it has taken\n        c-pass (if (true? accept-o) (conj remaining-p new-o) remaining-p)                                               ;If order taken add the current passengers to the new order passengers\n        ]\n\n    (hash-map :station n-station\n              :value val\n              :current-capacity final-cap\n              :max-capacity (get c-state :max-capacity)\n              :route c-route\n              :route-end (get c-state :route-end)\n              :current-passengers c-pass)))\n\n\n(defn lmg [states order]\n  \&quot;For each state maps all of the legal moves that can be reached.\n  Concatinating all of the different station states into one large list\&quot;\n  (let [fir (first states)]\n    (if (= (get fir :station)\n           (get fir :route-end))\n      states\n      (let [new-states (for [x states] (map #(move x %) (filter #(= (get % :start) (get x :station)) order)))]\n        (recur (apply concat new-states) order)))))\n\n\n(defn map-val [state order]\n  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n  (let [end (lmg (list (state)) order)]\n    (apply hash-map(map #(select-keys % [:value]) end))))\n\n(defn max-val [state order]\n  (let [maximum (map-val state order)]\n    (apply max(map :value\n                   (filter #(if (and (map? %) (:value %)) true false)\n                           (tree-seq #(or (map? %) (vector? %)) identity maximum))))))\n\n\n;(max-val #(make-state 0 3 10) orders)\n;=&gt; 30\n;(max-val #(make-state 0 3 10) orders2)\n;=&gt; 20\n;(max-val #(make-state 0 3 10) orders3)\n;=&gt; 25\n;(max-val #(make-state 0 3 10) orders4)\n;=&gt; 19\n;(max-val #(make-state 0 4 10) orders2)\n;=&gt; 29\n\n\n\n(def tests '([t1 (max-val #(make-state 0 3 10) orders) =&gt; 30] ;Standard tests\n              [t2 (max-val #(make-state 0 3 10) orders2) =&gt; 20]\n              [t3 (max-val #(make-state 0 4 10) orders2) =&gt; 25]\n              [t4 (max-val #(make-state 0 3 10) orders3) =&gt; 19]\n              [t5 (max-val #(make-state 0 3 10) orders4) =&gt; 29]\n              [t6 (max-val #(make-state 0 4 5) orders2) =&gt; 14] ;Tests with small capacity\n              [t7 (max-val #(make-state 0 3 5) orders4) =&gt; 3]\n              ))\n\n(defn the-solution [created-orders start-state]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n   does not exceed the maximum of 22. true is returned if it is within the limit\n    else false\&quot;\n  (if (&lt; (count (flatten created-orders)) 22)\n    (max-val start-state created-orders)\n    '(Order-Failed)))\n\n\n\n;(map :value\n;     (filter #(if (and (map? %) (:value %)) true  false)\n;             (tree-seq #(or (map? %) (vector? %)) identity mymap)))\n;=&gt; (30 30 12 19 13 10)\n\n\n;BELOW IS WHAT NEEDS DOING==============================================================================================\n; test harness completion\n; test data to break\n; need to get the max value from the map of values\n;Create a test harness that will check each of the values indivually\n\n;---------TESTING-----------\n; assert ðŸ˜Š (get (move state )) :current-capacity)\n;(lmg (list (make-state 0 3 10)) orders)\n;(lmg (list (make-state 0 4 10)) order2)\n\n\n\n;(defn max-val [state order]\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end)\n;    ))\n;\n;(def tests '([t1 ((max-val #(make-state 0 3 10) orders)\n;                   =&gt; ({:value 30} {:value 30} {:value 12} {:value 19} {:value 13} {:value 10}))]\n;              [t1 (first ((max-val #(make-state 0 3 10) orders))) =&gt; {:value 30}]\n;\n;              ;(lmg (list (make-state 0 4 10)) order2)\n;\n;              ))\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4]\n;              [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n\n;(def data [{:date1 \&quot;20131007\&quot;, :data \&quot;object1\&quot;, :counter 1000}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object2\&quot;, :counter 50}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object3\&quot;, :counter 230}])\n;\n;(def counters (map :counter data))      ; =&gt; (100 50 230)\n;(def min-value (apply min counters))    ; =&gt; 50\n;(def max-value (apply max counters))    ; =&gt; 1000\n;(def val-range (- max-value min-value)) ; =&gt; 950\n;(def val-pc (* (/ val-range 100) 10))   ; =&gt; 95\n;(def x (- max-value val-pc))            ; =&gt; 905\n\n;BELOW IS WHAT NEEDS DOING==============================================================================================\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end))\n;\n;  )\n;(defn maxx-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (apply hash-map(map #(select-keys % [:value]) end))))\n;\n;\n;\n;(defn omgffs [state order]\n;  (let [please-work (maxx-val state order)]\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity please-work)))))\n; test harness completion\n; test data to break\n; need to get the max value from the map of values\n;Create a test harness that will check each of the values indivually\n\n;---------TESTING-----------\n; assert (= (get (move state )) :current-capacity)\n;(lmg (list (make-state 0 3 10)) orders)\n;(lmg (list (make-state 0 4 10)) order2)\n\n;(defn run-all-tests [tests]\n;  (mfor ['(?id ?test =&gt; ?res) tests]\n;        (if-not (= (eval (? test)) (eval (? res)))\n;          (println (mout '(FAILED ?id ?test =&gt; ?res))))) 'end-of-testing)\n;\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4] [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n;\n;;(defn max-val [state order]\n;;  (let [end (lmg (list (state)) order)]\n;;    (map #(select-keys % [:value]) end)\n;;    ))\n;\n;(def tests '([t1 ((max-val #(make-state 0 3 10) orders) =&gt; ({:value 30} {:value 30} {:value 12} {:value 19} {:value 13} {:value 10}))]\n;              [t1 (first ((max-val #(make-state 0 3 10) orders))) =&gt; {:value 30}]\n;\n;              ;(lmg (list (make-state 0 4 10)) order2)\n;\n;              ))\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4]\n;              [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n\n;(def data [{:date1 \&quot;20131007\&quot;, :data \&quot;object1\&quot;, :counter 1000}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object2\&quot;, :counter 50}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object3\&quot;, :counter 230}])\n;\n;(def counters (map :counter data))      ; =&gt; (100 50 230)\n;(def min-value (apply min counters))    ; =&gt; 50\n;(def max-value (apply max counters))    ; =&gt; 1000\n;(def val-range (- max-value min-value)) ; =&gt; 950\n;(def val-pc (* (/ val-range 100) 10))   ; =&gt; 95\n;(def x (- max-value val-pc))            ; =&gt; 905\n\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    end))\n\n\n\n;Old shit\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (for [n end] (get (nth end n) :value)\n;    )))\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (get (nthrest end 0) :value)\n;    ))\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    (first end)))\n\n;(defn maxx-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (apply hash-map(map #(select-keys % [:value]) end))\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (#(select-keys % [:value]) end)\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))&quot; &quot;(ns Uva301)\n;\n;(defn make-order [start end passengers]\n;  ;Makes an order\n;  \&quot;Creates a map start, end (station) and number of passengers.\n;  Also contains a function to calculate value.\&quot;\n;  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n;\n;\n;(def empty-orders\n;  \&quot;Empty list for test purposes\&quot;\n;  (list ()))\n;\n;\n;(def orders\n;  \&quot;Creates mock orders\&quot;\n;  (list (make-order 0 2 10)                                 ;20\n;        (make-order 0 2 1)                                  ;2\n;        (make-order 0 3 1)                                  ;3\n;        (make-order 1 3 5)                                  ;10\n;        (make-order 1 2 7)                                  ;7\n;        (make-order 2 3 10)                                 ;10\n;        ))\n;\n;\n;(def orders2\n;  \&quot;Creates more mock orders\&quot;\n;  (list (make-order 0 2 4)\n;        (make-order 0 1 7)\n;        (make-order 1 3 5)\n;        (make-order 1 2 10)\n;        (make-order 1 2 3)\n;        (make-order 2 4 1)\n;        (make-order 2 3 2)\n;        (make-order 3 4 7)\n;        (make-order 3 4 9)\n;        (make-order 3 4 4)\n;        ))\n;\n;\n;(defn make-state [current-station end-station max-capacity]\n;  \&quot;Defines the current state of station, capacity, route and passengers onboard.\n;   To work out passenger calculations\&quot;\n;  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n;            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n;\n;\n;(def start-state\n;  \&quot;Defines the problem default start state\&quot;\n;  (make-state 0 4 10))\n;\n;\n;(defn move [c-state new-o]\n;  \&quot;Moves through the orders updating the current status accepting or\n;  rejecting orders subject to define conditions. Stores accept order states in hash map\&quot;\n;  (let [c-station (get c-state :station)\n;        n-station (inc c-station)\n;        p-off (filter #(= (get % :end) c-station) (get c-state :current-passengers))\n;        remaining-p (filter #(not (= (get % :end) c-station)) (get c-state :current-passengers))\n;        reduce-cap (reduce #(+ %1 (get %2 :pass)) 0 p-off)\n;        dep-cap (- (get c-state :current-capacity) reduce-cap)\n;        accept-o (if (&lt;= (+ dep-cap (get new-o :pass)) (get c-state :max-capacity)) true false)\n;        final-cap (if (true? accept-o) (+ dep-cap (get new-o :pass)) dep-cap)\n;        val (if (true? accept-o) (+ (get c-state :value) (get new-o :value)) (get c-state :value))\n;        c-route (if (true? accept-o) (conj (get c-state :route) new-o) (get c-state :route))\n;        c-pass (if (true? accept-o) (conj remaining-p new-o) remaining-p)\n;        ]\n;\n;    (hash-map :station n-station\n;              :value val\n;              :current-capacity final-cap\n;              :max-capacity (get c-state :max-capacity)\n;              :route c-route\n;              :route-end (get c-state :route-end)\n;              :current-passengers c-pass)))\n;\n;\n;(defn lmg [states order]\n;  \&quot;For each state maps all of the legal moves that can be reached.\n;  Concatinating all of the different station states into one large list\&quot;\n;  (let [fir (first states)]\n;    (if (= (get fir :station)\n;           (get fir :route-end))\n;      states\n;      (let [new-states (for [x states] (map #(move x %) (filter #(= (get % :start) (get x :station)) order)))]\n;        (recur (apply concat new-states) order)))))\n;\n;\n;(defn map-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (apply hash-map (map #(select-keys % [:value]) end))))\n;\n;(defn max-val [state order]\n;  \&quot;gets the maxium from the list\&quot;\n;  (let [maximum (map-val state order)]\n;    (apply max (map :value\n;                    (filter #(if (and (map? %) (:value %)) true false)\n;                            (tree-seq #(or (map? %) (vector? %)) identity maximum))))))\n;\n\n\n;======================================================================================================================\n(ns GroupF-UVA301)\n\n(defn make-order [start end passengers]\n  ;Makes an order\n  \&quot;Creates a map start, end (station) and number of passengers.\n  Also contains a function to calculate value.\&quot;\n  (hash-map :start start :end end :pass passengers :value (* (- end start) passengers)))\n\n\n(def empty-orders\n  \&quot;Empty list for test purposes\&quot;\n  (list ()))\n\n\n(def orders\n  \&quot;Creates mock orders\&quot;\n  (list (make-order 0 2 10)                                 ;20\n        (make-order 0 2 1)                                  ;2\n        (make-order 0 3 1)                                  ;3\n        (make-order 1 3 5)                                  ;10\n        (make-order 1 2 7)                                  ;7\n        (make-order 2 3 10)                                 ;10\n        ))\n\n\n(def orders2\n  \&quot;Creates more mock orders\&quot;\n  (list (make-order 0 2 4)\n        (make-order 0 1 7)\n        (make-order 1 3 5)\n        (make-order 1 2 10)\n        (make-order 1 2 3)\n        (make-order 2 4 1)\n        (make-order 2 3 2)\n        (make-order 3 4 7)\n        (make-order 3 4 9)\n        (make-order 3 4 4)\n        ))\n\n\n(def orders3\n  \&quot;Creates more mock orders\&quot;\n  (list (make-order 0 3 4)\n        (make-order 0 1 1)\n        (make-order 1 3 6)\n        (make-order 1 2 10)\n        (make-order 1 2 1)\n        (make-order 2 4 6)\n        (make-order 2 3 2)\n        (make-order 3 4 7)\n        (make-order 3 4 9)\n        (make-order 3 4 4)\n        ))\n\n(def orders4\n  ;Makes oversized order for test\n  \&quot;Creates mock orders that is over the size limit\&quot;\n  (list (make-order 0 2 1)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 0 3 1)\n        (make-order 1 3 5)\n        (make-order 1 2 7)\n        (make-order 2 3 10)))\n\n\n(defn make-state [current-station end-station max-capacity]\n  \&quot;Defines the current state of station, capacity, route and passengers onboard.\n   To work out passenger calculations\&quot;\n  (hash-map :station current-station :value 0 :current-capacity 0 :max-capacity max-capacity\n            :route (cons current-station '()) :route-end end-station :current-passengers '()))\n\n(def start-state\n  \&quot;Defines the problem default start state\&quot;\n  (make-state 0 4 10))\n\n\n\n\n(defn move [c-state new-o]\n  \&quot;Moves through the orders updating the current status accepting or\n  rejecting orders subject to define conditions. Stores accept order states in hash map\&quot;\n  (let [c-station (get c-state :station)                                                                                ;Sets the current station\n        n-station (inc c-station)                                                                                       ;increments through the stations\n        p-off (filter #(= (get % :end) c-station) (get c-state :current-passengers))                                    ;Filters where the end station is equal to the current station, if it is it will then get the current passengers\n        remaining-p (filter #(not (= (get % :end) c-station)) (get c-state :current-passengers))                        ;Filters where the end station is not equal to the current station passngers will be staying on so get the current passengers\n        reduce-cap (reduce #(+ %1 (get %2 :pass)) 0 p-off)                                                              ;Start at 0 then adds the people that are getting off so it increases our capacity so that more people can get on\n        dep-cap (- (get c-state :current-capacity) reduce-cap)                                                          ;Gets the current capacity and reduced then takes them off leaving the current capacity when the train has dropped people off\n        accept-o (if (&lt;= (+ dep-cap (get new-o :pass)) (get c-state :max-capacity)) true false)                         ;If the capacity that is currently on the train + the new orders passengers is less than the max capacity it is true. Else false\n        final-cap (if (true? accept-o) (+ dep-cap (get new-o :pass)) dep-cap)                                           ;If true set accept the order and add the current capacity with the new order passengers\n        val (if (true? accept-o) (+ (get c-state :value) (get new-o :value)) (get c-state :value))                      ;If order taken update the value\n        c-route (if (true? accept-o) (conj (get c-state :route) new-o) (get c-state :route))                            ;If order taken conj the current route with the new order route, create a long list of the route it has taken\n        c-pass (if (true? accept-o) (conj remaining-p new-o) remaining-p)                                               ;If order taken add the current passengers to the new order passengers\n        ]\n\n    (hash-map :station n-station\n              :value val\n              :current-capacity final-cap\n              :max-capacity (get c-state :max-capacity)\n              :route c-route\n              :route-end (get c-state :route-end)\n              :current-passengers c-pass)))\n\n\n(defn lmg [states order]\n  \&quot;For each state maps all of the legal moves that can be reached.\n  Concatinating all of the different station states into one large list\&quot;\n  (let [fir (first states)]\n    (if (= (get fir :station)\n           (get fir :route-end))\n      states\n      (let [new-states (for [x states] (map #(move x %) (filter #(= (get % :start) (get x :station)) order)))]\n        (recur (apply concat new-states) order)))))\n\n\n(defn map-val [state order]\n  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n  (let [end (lmg (list (state)) order)]\n    (apply hash-map(map #(select-keys % [:value]) end))))\n\n(defn max-val [state order]\n  (let [maximum (map-val state order)]\n    (apply max(map :value\n                   (filter #(if (and (map? %) (:value %)) true false)\n                           (tree-seq #(or (map? %) (vector? %)) identity maximum))))))\n\n(defn the-solution [created-orders start-state]\n  \&quot;Helper function to validate that the given map/hashmap etc..\n   does not exceed the maximum of 22. true is returned if it is within the limit\n    else false\&quot;\n  (if (&lt; (count (flatten created-orders)) 22)\n    (max-val start-state created-orders)\n    '(Order-Failed)))\n\n\n;(max-val #(make-state 0 3 10) orders)\n;=&gt; 30\n;(max-val #(make-state 0 3 10) orders2)\n;=&gt; 20\n;(max-val #(make-state 0 3 10) orders3)\n;=&gt; 25\n;(max-val #(make-state 0 3 10) orders4)\n;=&gt; 19\n;(max-val #(make-state 0 4 10) orders2)\n;=&gt; 29\n\n\n\n(def tests '([t1 (max-val #(make-state 0 3 10) orders) =&gt; 30] ;Standard tests\n              [t2 (max-val #(make-state 0 3 10) orders2) =&gt; 20]\n              [t3 (max-val #(make-state 0 4 10) orders2) =&gt; 25]\n              [t4 (max-val #(make-state 0 3 10) orders3) =&gt; 19]\n              [t5 (max-val #(make-state 0 3 10) orders4) =&gt; 29]\n              [t6 (max-val #(make-state 0 4 5) orders2) =&gt; 14] ;Tests with small capacity\n              [t7 (max-val #(make-state 0 3 5) orders4) =&gt; 3]\n              ))\n\n\n\n\n\n;(map :value\n;     (filter #(if (and (map? %) (:value %)) true  false)\n;             (tree-seq #(or (map? %) (vector? %)) identity mymap)))\n;=&gt; (30 30 12 19 13 10)\n\n\n;BELOW IS WHAT NEEDS DOING==============================================================================================\n; test harness completion\n; test data to break\n; need to get the max value from the map of values\n;Create a test harness that will check each of the values indivually\n\n;---------TESTING-----------\n; assert ðŸ˜Š (get (move state )) :current-capacity)\n;(lmg (list (make-state 0 3 10)) orders)\n;(lmg (list (make-state 0 4 10)) order2)\n\n\n\n;(defn max-val [state order]\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end)\n;    ))\n;\n;(def tests '([t1 ((max-val #(make-state 0 3 10) orders)\n;                   =&gt; ({:value 30} {:value 30} {:value 12} {:value 19} {:value 13} {:value 10}))]\n;              [t1 (first ((max-val #(make-state 0 3 10) orders))) =&gt; {:value 30}]\n;\n;              ;(lmg (list (make-state 0 4 10)) order2)\n;\n;              ))\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4]\n;              [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n\n;(def data [{:date1 \&quot;20131007\&quot;, :data \&quot;object1\&quot;, :counter 1000}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object2\&quot;, :counter 50}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object3\&quot;, :counter 230}])\n;\n;(def counters (map :counter data))      ; =&gt; (100 50 230)\n;(def min-value (apply min counters))    ; =&gt; 50\n;(def max-value (apply max counters))    ; =&gt; 1000\n;(def val-range (- max-value min-value)) ; =&gt; 950\n;(def val-pc (* (/ val-range 100) 10))   ; =&gt; 95\n;(def x (- max-value val-pc))            ; =&gt; 905\n\n;BELOW IS WHAT NEEDS DOING==============================================================================================\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (map #(select-keys % [:value]) end))\n;\n;  )\n;(defn maxx-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (apply hash-map(map #(select-keys % [:value]) end))))\n;\n;\n;\n;(defn omgffs [state order]\n;  (let [please-work (maxx-val state order)]\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity please-work)))))\n; test harness completion\n; test data to break\n; need to get the max value from the map of values\n;Create a test harness that will check each of the values indivually\n\n;---------TESTING-----------\n; assert (= (get (move state )) :current-capacity)\n;(lmg (list (make-state 0 3 10)) orders)\n;(lmg (list (make-state 0 4 10)) order2)\n\n;(defn run-all-tests [tests]\n;  (mfor ['(?id ?test =&gt; ?res) tests]\n;        (if-not (= (eval (? test)) (eval (? res)))\n;          (println (mout '(FAILED ?id ?test =&gt; ?res))))) 'end-of-testing)\n;\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4] [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n;\n;;(defn max-val [state order]\n;;  (let [end (lmg (list (state)) order)]\n;;    (map #(select-keys % [:value]) end)\n;;    ))\n;\n;(def tests '([t1 ((max-val #(make-state 0 3 10) orders) =&gt; ({:value 30} {:value 30} {:value 12} {:value 19} {:value 13} {:value 10}))]\n;              [t1 (first ((max-val #(make-state 0 3 10) orders))) =&gt; {:value 30}]\n;\n;              ;(lmg (list (make-state 0 4 10)) order2)\n;\n;              ))\n;\n;(def tests '([t1 (+ 2 2) =&gt; 4]\n;              [t2 (- 3 2) =&gt; 'banana]\n;              [t3 (first '(cat bat rat)) =&gt; 'cat]\n;              [t4 (first '(cat bat rat)) =&gt; 'sat]))\n\n;(def data [{:date1 \&quot;20131007\&quot;, :data \&quot;object1\&quot;, :counter 1000}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object2\&quot;, :counter 50}\n;           {:date1 \&quot;20131007\&quot;, :data \&quot;object3\&quot;, :counter 230}])\n;\n;(def counters (map :counter data))      ; =&gt; (100 50 230)\n;(def min-value (apply min counters))    ; =&gt; 50\n;(def max-value (apply max counters))    ; =&gt; 1000\n;(def val-range (- max-value min-value)) ; =&gt; 950\n;(def val-pc (* (/ val-range 100) 10))   ; =&gt; 95\n;(def x (- max-value val-pc))            ; =&gt; 905\n\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    end))\n\n\n\n;Old shit\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (for [n end] (get (nth end n) :value)\n;    )))\n\n;(defn max-val [state order]\n;(let [end (legal-move-gen (list (state)) order)]\n;  (get (nthrest end 0) :value)\n;    ))\n\n;(defn max-val [state order]\n;  (let [end (legal-move-gen (list (state)) order)]\n;    (first end)))\n\n;(defn maxx-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (apply hash-map(map #(select-keys % [:value]) end))\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))\n;(defn max-val [state order]\n;  \&quot;Pulls values produced by the legal move generator. Values are mapped for comparison\&quot;\n;  (let [end (lmg (list (state)) order)]\n;    (#(select-keys % [:value]) end)\n;    (map :value\n;         (filter #(if (and (map? %) (:value %)) true  false)\n;                 (tree-seq #(or (map? %) (vector? %)) identity end)))\n;    ))&quot; &quot;(max-val #(make-state 0 3 10) orders)&quot; &quot;(the-solution #(make-state 0 3 10) orders)&quot; &quot;(max-val (make-state 0 3 10) orders)&quot;], :remote []}}</component>
</project>